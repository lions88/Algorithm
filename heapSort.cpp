/*
 *	堆排序
	时间复杂度：O(nlogn)
	空间复杂度：O(1)
	属于不稳定排序算法。

  (1)用大根堆排序的基本思想
	① 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区
	② 再将关键字最大的记录R[1](即堆顶)和无序区的最后一个记录R[n]交换，
  由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key
	③ 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。
  然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，
  由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n- 2].keys≤R[n-1..n].keys，
  同样要将R[1..n-2]调整为堆。
  ……
  直到无序区只有一个元素为止。
  
  (2)大根堆排序算法的基本操作：
	① 初始化操作：将R[1..n]构造为初始堆；
	② 每一趟排序的基本操作：将当前无序区的堆顶记录R[1]和该区间的最后一个记录交换，然后将新的无序区调整为堆(亦称重建堆)。
	注意：
	①只需做n-1趟排序，选出较大的n-1个关键字即可以使得文件递增有序。
	②用小根堆排序与利用大根堆类似，只不过其排序结果是递减有序的。
	堆排序和直接选择排序相反：在任何时刻，堆排序中无序区总是在有序区之前，
	且有序区是在原向量的尾部由后往前逐步扩大至整个向量为止。 
 */

/*
 *	eg.数组{16, 7, 3, 20, 17, 8}
				 16
			   /    \
		      7      3
			 / \    /
		    20  17 8

	1.调整为最大堆
				 20
			   /    \
			  17     8
			 / \    /
			7  16  3

	2.首元素[3]和尾元素[20]交换
				3
			  /   \
			 17    8    
			/ \   /
		   7  16 20
	  将前5个元素（元素20除外）调整为最大堆
			   17
			 /    \
			16     8    
		   / \    /
		  7  3  20
    
	3.首元素[17]和倒数第2个元素[3]交换
				3
			  /   \
			16     8    
		   / \    /
		  7  17  20
	  将前4个元素（20和17除外）调整为最大堆
				16
			  /    \
			 7      8    
			/ \    /
		   3  17  20

    4.首元素[16]和倒数第3个元素[3]交换
				3
			  /   \
			 7     8    
			/ \    /
		   16 17  20
    
	5.首元素[3]和倒数第4个元素[8]交换
				8
			  /   \
			 7     3    
			/ \    /
		   16 17  20
	   将前3个元素调整为最大堆
				3
			  /   \
			 7     8    
			/ \    /
		  16 17  20

    6.首元素[3]和倒数第5个元素[7]交换
				7
			  /   \
			 3     8    
			/ \    /
		   16 17  20
	  将前两个元素调整为最大堆
				3
			  /   \
			 7     8    
			/ \    /
		   16 17  20
 */

#include <iostream>
using namespace std;

/*
 *	调整为最大堆
 */
void HeapAdjust(int *arr, int index, int len)
{
	while(2*index+1 < len){
		//左孩子索引
		int childIndex = 2*index+1;
		if(2*index+2 < len){
			if(arr[2*index+1] < arr[2*index+2]){
				//右孩子索引
				childIndex = 2*index + 2;
			}
		}
		if (arr[index] < arr[childIndex])
		{
			int tmp = arr[index];
			arr[index] = arr[childIndex];
			arr[childIndex] = tmp;
			index = childIndex;
		}
		else{
			break;
		}
	}
}

void HeapSort(int *arr, int len)
{
	int i;
	//将整个数组按最大堆排序
	for(i=len/2-1; i>=0; i--)
	{
		// len/2-1是最后一个非叶节点
		HeapAdjust(arr, i, len);
	}

	//将arr[0..i)按最大堆排序
	for (i = len-1; i>0; i--)
	{
		//arr[0]是最大的一个元素，将其与arr[i]交换，使大元素排到数组尾部
		int tmp = arr[0];
		arr[0] = arr[i];
		arr[i] = tmp;
		//交换后破坏了最大堆，arr[0..i)重新按最大堆排序
		HeapAdjust(arr, 0, i);
	}
}

int main()
{
	int array[] = {16, 7, 3, 20, 17, 8};
	HeapSort(array, 6);
	
	for(int i=0; i<6; i++)
		cout<<array[i]<<"  ";
	cout<<endl;
	return 0;
}